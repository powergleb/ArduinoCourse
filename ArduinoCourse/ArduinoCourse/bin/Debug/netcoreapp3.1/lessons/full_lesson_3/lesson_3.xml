<Lesson>
  <Title>Урок 3. Цифровые контакты ввода-вывода шиотно-импульсная модуляция</Title>
  <Theories>
    <Theory>
      <Title>3.1) Список деталей</Title>
      <Text>Для повторения примеров главы понадобятся следующие детали:
• плата Arduino Uno;
• макетная плата;
• перемычки;
• 1 резистор номиналом 10 кОм;
• 3 резистора номиналом 220 Ом;
• кабель USB;
• кнопка;
• одноцветный светодиод 5 мм;
• RGB-светодиод 5 мм с общим катодом.
У большинства плат Arduino нет аналоговых выходов, но их можно эмулировать с помощью широтно-импульсной модуляции (ШИМ).
Далее мы расскажем, как сформировать ШИМ-сигнал.
Прочитав главу, вы сможете создать ночник на RGB-светодиоде.
Проект с мигающим светодиодом, рассмотренный в предыдущей главе, скорее игрушка, чем полезное устройство.
Действительно привлекательной для разработчиков делает платформу Arduino наличие контактов ввода-вывода.
К плате можно подключить, например, геркон, и при открытии двери проигрывать какую-либо мелодию или создать электронный сейф, или несложный музыкальный инструмент.
В этом уроке вы приступите к разработке новых проектов: познакомитесь с возможностями цифровых входов Arduino, узнаете о подтягивающих (pull-up) и стягивающих (pull-down) резисторах и научитесь управлять цифровыми выходами.</Text>
      <Pics />
    </Theory>
    <Theory>
      <Title>3.2) Цифровые контакты</Title>
      <Text>В главе 2 вы узнали, как заставить мигать светодиод, подключенный к цифровому контакту. Продолжим изучать возможности цифровых выходов Arduino и рассмотрим следующие темы:
• конфигурирование назначения цифровых выводов;
• подключение внешних компонентов;
• новые концепции программирования циклов и констант;
• различие между цифровыми и аналоговыми выходами;
• широтно-импульсная модуляция (ШИМ).</Text>
      <Pics />
    </Theory>
    <Theory>
      <Title>3.3) Подключение внешнего светодиода</Title>
      <Text>Мигающий светодиод из предыдущего примера был встроен в плату Arduino.
Теперь настало время выйти за пределы платы и соединить ее контакт 9 с внешним светодиодом.
Этот простой пример поможет вам понять, как собирать более сложные внешние цепи, описанные в следующих уроках.
Более того, контакт 9 Arduino позволяет формировать сигнал широтно-импульсной модуляции, что мы используем далее в этом уроке.
Рассмотрим, что такое макетная плата и как эффективно использовать ее для проектов из этой книги. Макетная плата - удобный инструмент для экспериментов, позволяющий легко собирать простые схемы без изготовления печатных плат и пайки.
С двух сторон по всей длине макетной платы расположены красные и синие
отверстия. Все красные отверстия соединены между собой и служат, как правило, для подачи питания. Для большинства проектов из этой книги это +5 В.
Все синие отверстия тоже электрически соединены друг с другом и играют роль шины заземления.
Каждые пять отверстий, расположенных вертикальными рядами, также соединены друг с другом.
Посередине есть свободное место для удобства установки компонентов на макетной плате. Электрические соединения отверстий показаны на рисунке утолщенными линиями.
Шина питания Шина заземления (общая шина)
Шина питания Шина заземления (общая шина)
Область для установки элементов</Text>
      <Pics>
        <Pic>\lessons\lesson_3\pic\pic3.1.jpg</Pic>
      </Pics>
    </Theory>
    <Theory>
      <Title>3.4) Подсоединение светодиодов</Title>
      <Text>Светодиоды почти наверняка будут одними из наиболее часто используемых деталей в проектах из данной книги.
Подключая светодиоды, необходимо соблюдать правильную полярность. Положительный вывод светодиода называется анодом, отрицательный - катодом.
Определить назначение контактов светодиода можно визуально: вывод катода короче, чем анода.
Ток через светодиод течет только в одном направлении: от анода к катоду.
Поскольку ток протекает от положительного полюса к отрицательному, анод светодиода следует подключить к источнику тока (цифровой выход +5 В), а катод к земле.
Резистор может быть подключен последовательно с любым из выводов светодиода.
Полярность подключения для резисторов не важна.
Подключать светодиод к контакту 9 Arduino нужно последовательно с резистором, который выступает в качестве ограничителя тока.
Чем больше сопротивление резистора, тем сильнее он ограничивает ток.
В этом примере мы применим резистор номиналом 220 Ом.
Монтажная схема изображена на рисунке.</Text>
      <Pics>
        <Pic>\lessons\lesson_3\pic\pic3.2.jpg</Pic>
      </Pics>
    </Theory>
    <Theory>
      <Title>3.5.1) Закон Ома и формула для расчета мощности, теория</Title>
      <Text>Самая главная формула для любого инженера-электрика - это закон Ома, который определяет соотношение между напряжением (измеряется в вольтах), током (измеряется в амперах) и сопротивлением (измеряется в Омах) в цепи.
Схема представляет собой замкнутый контур с источником электрической энергии ( например, батареей 9 В) и нагрузкой (чем-то, что расходует энергию, как светодиод).
Прежде всего, важно понять физический смысл каждого термина:
• напряжение представляет собой разность электрических потенциалов между двумя точками;
• ток течет от точки с более высокой потенциальной энергией, чтобы снизить потенциальную энергию.
Пользуясь аналогией, электрический ток можно представить как поток воды, а напряжение - как высоту перепада.
Вода (или ток) всегда течет из точки с большей высотой (более высокое напряжение) к точке с меньшей высотой (или более низкому напряжению).
Ток, как вода в реке, всегда будет идти по пути наименьшего сопротивления в цепи;
по аналогии сопротивление является отверстием для протекания тока.
Когда вода (ток) течет через узкую трубу, за одинаковое количество времени проходит меньшее количество, чем через широкую трубу.
Узкая труба эквивалентна большему сопротивлению, потому что вода будет течь медленнее.
Широкая труба эквивалентна малому сопротивлению, потому что вода (ток) может течь быстрее.
Закон Ома определяется следующим образом:
U = I·R, где U - напряжение в вольтах; I - ток в амперах; R - сопротивление в омах.</Text>
      <Pics />
    </Theory>
    <Theory>
      <Title>3.5.2) Закон Ома и формула для расчета мощности, практика</Title>
      <Text>В электрической цепи каждый компонент обладает некоторым сопротивлением, что снижает напряжение.
Закон Ома очень удобен для подбора значения резистора, подкточаемого последовательно со светодиодом.
Светодиоды характеризуются определенной величиной падения напряжения и заданным значением рабочего тока.
Чем больше ток через светодиод (не превышая максимально допустимого), тем ярче он светится.
Для наиболее распространенных светодиодов максимальный ток равен 20 мА.
Типовое значение падения напряжения для светодиода составляет около 2 в.
Рассмотрим схему, изображенную на рисунке, и применим закон Ома для подбора резистора R1.
Предположим, что LED 1 - стандартный светодиод с прямым током 20 мА и падением напряжения 2 В.
Напряжение питания 5 В должно перераспределиться между светодиодом и резистором.
Поскольку доля светодиода составляет 2 В, оставшиеся 3 В должны быть приложены к резистору.
Зная максимальное значение прямого тока через светодиод (20 мА), можно найти номинал резистора:
R = U/I= 3/0,02 = 150 Ом.
Таким образом, при сопротивлении резистора 150 Ом через него и светодиод протекает ток 20 мА.
По мере увеличения сопротивления ток будет уменьшаться.
Резистор 220 Ом обеспечивает достаточную яркость свечения светодиода, к тому же этот номинал очень распространен.
Еще одно важное соотношение - формула для расчета мощности, которая показывает, сколько ватт рассеивается на каждом компоненте.
Увеличение мощности рассеивания связано с ростом тепловыделения прибора.
Для каждого компонента, как правило, задается максимально допустимая мощность.
Максимальная мощность резистора в нашем примере равна 0,125 Вт.
Формула для расчета мощности выглядит следующим образом:
Р = U·I, где Р - мощность, Вт; U- напряжение, В; I - сила тока, А.
Для резистора из схемы на рис. 2.3 при падении напряжения 3 В и силе тока 20 мА мощность равна
Р = 3·0,02 = 0,06 Вт.
Поскольку 60 мВт меньше 0,125 Вт = 125 мВт, следовательно, данный резистор не перегреется.</Text>
      <Pics>
        <Pic>\lessons\lesson_3\pic\pic3.3.jpg</Pic>
      </Pics>
    </Theory>
    <Theory>
      <Title>3.6.1) Программирование цифровых выводов</Title>
      <Text>По умолчанию все внешние контакты Arduino сконфигурированы как входы. 
Если необходимо использовать контакт Arduino как выход, нужно его переконфигурировать, подав соответствующую команду микроконтроллеру.
Каждая программа для Arduino должна включать две обязательные функции:
setup() И loop().
В уроке 2 уже упоминалось, что функция setup() запускается один раз в начале программы, а loop() работает как цикл. Поскольку каждый контакт обычно конфигурируется в программе один раз, логично делать это в теле функции setup().
Для начала напишем простую программу, которая при запуске сконфигурирует контакт 9 как выход.
В программе будут еще две функции: pinMode() - для конфигурации контакта и digitalWrite() - для установки значения HIGH (5 В) на этом контакте (листинг 3.1 далее).</Text>
      <Pics />
    </Theory>
    <Theory>
      <Title>3.6.2) Листинг 3.1. Пример конфигурации</Title>
      <Text>const int LED = 9; // Константа - номер контакта светодиода
void setup()
{
	pinMode (LED, OUTPUT); // Конфигурируем контакт светодиода как выход
	digitalWrite(LED, HIGH); // Устанавливаем значение HIGH на выходе
}
void loop()
{
	// В цикле ничего не выполняем
}</Text>
      <Pics />
    </Theory>
    <Theory>
      <Title>3.6.3) О константах и инструкция</Title>
      <Text>Соберите схему, как показано на рисунке, и загрузите код листинга 3.1 в плату Arduino. 
Обратите внимание, что в этой программе использовал оператор инициализации константы перед определением значения контакта Arduino.
Обычно для хранения значений, которые могут изменяться во время выполнения программы, предназначены переменные.
Поставив оператор const до объявления переменной, вы говорите компилятору, что это переменная "только для чтения" и она не будет изменяться во время выполнения программы.
Всем экземплярам переменной LED в программе будет присвоено значение 9.
В виде констант рекомендуется определять значения, которые не будут меняться при выполнении программы.
Далее в некоторых примерах этой главы встретится иная ситуация: значения, которые могут изменяться при выполнении программы.
При объявлении любой переменной необходимо указать ее тип. В нашем случае это целое число (номера контактов всегда будут целыми числами).
Теперь попробуйте изменить программу из главы 2, добавив функцию digitalWrite() и введя задержку в цикле loop().
Экспериментируя со значениями задержки, можно создавать различные эффекты мигания.</Text>
      <Pics>
        <Pic>\lessons\lesson_3\pic\pic3.2.jpg</Pic>
      </Pics>
    </Theory>
    <Theory>
      <Title>3.7.1) Использование цикла, теория</Title>
      <Text>На практике часто необходимо циклически изменять значения переменных для выполнения заданного алгоритма.
В предыдущем примере можно реализовать цикл, чтобы увидеть, как влияют на частоту мигания разные значения задержки.
Вы можете реализовать разные скорости мигания, задавая с помощью переменной цикла различные значения задержки.
Пример иллюстрирует код из листинга 3.2 (далее).</Text>
      <Pics />
    </Theory
    <Theory>
      <Title>3.7.2) Листинг 3.2. Изменение частоты мигания светодиода</Title>
      <Text>const int LED = 9; // Константа - номер контакта светодиода
void setup()
{
	pinMode (LED, OUTPUT); // Конфигурируем контакт светодиода как выход
}
void loop()
{
	for (int i = 100; i <= 1000; i = i + 100)
	{
		digitalWrite(LED, HIGH);
		delay(i);
		digitalWrite(LED, LOW);
		delay(i);
	}
}</Text>
      <Pics />
    </Theory>
    <Theory>
      <Title>3.7.3) Пояснение к листингу 3.2</Title>
      <Text>Скомпилируйте код листинга 3.2, загрузите его на свою плату Arduino и посмотрите, что происходит.
Теперь разберемся, как это работает.
Оператор for всегда содержит три выражения, разделенные точкой с запятой:
• первое выражение присваивает начальное значение переменной-счетчику цикла.
В нашем примере переменная i получает начальное значение 100;
• второе выражение указывает, когда цикл должен остановиться. Операторы в теле цикла будут выполняться снова и снова, пока условие истинно.
Запись <= означает меньше или равно.
Таким образом, этот цикл будет выполняться тех пор, пока переменная i меньше или равна 1000;
• последнее выражение указывает, что должно произойти с переменной i каждый раз после выполнения операторов тела цикла.
В нашем примере, значение счетчика цикла увеличивается на 100.</Text>
      <Pics />
    </Theory>
    <Theory>
      <Title>3.7.4) Пошаговый разбор листинга 3.2</Title>
      <Text>Чтобы лучше понять работу оператора for, подробно рассмотрим, что происходит за два прохода цикла:
1. Значение переменной i равно 100, 100 меньше или равно 1000, значит выполнять код в теле цикла.
2. На контакте 9 установлено значение HIGH, светодиод горит 100 мс (текущее значение i).
3. На контакт 9 подано значение LOW, светодиод потушен 100 мс (текущее значение i).
4. В конце цикла значение переменной i увеличивается на 100, теперь i равно 200.
5. 200 меньше или равно 1000, цикл повторяется снова.
6. На контакте 9 установлено значение HIGH, светодиод горит 200 мс (текущее значение i).
7. На контакт 9 подано значение LOW, светодиод потушен 200 мс (текущее значение i).
8. В конце цикла значение переменной i увеличивается на 100, теперь i равно 300.
9. Этот процесс повторяется, пока i не превосходит 1000 и затем i снова принимает значение 100 и все повторяется заново.
Итак, вы разобрались с работой цифровых контактов платы Arduino.
Далее разберемся, как с помощью ШИМ сформировать аналоговые сигналы на цифровых контактах платы Arduino.</Text>
      <Pics />
    </Theory>
    <Theory>
      <Title>3.8.1) Широтно-импульсная модуляция с помощью analogWrite(), теория</Title>
      <Text>Вы освоили контроль над цифровыми контактами Arduino.
Они очень удобны для переключения светодиодов, управления реле и двигателями постоянного тока.
Но что делать, если необходимо вывести напряжение, отличное от 0 и 5 В.
С помощью контактов одной только платы Arduino Uno это невозможно.
Придется задействовать цифроаналоговый преобразователь или взять плату Arduino Due или добавить внешнюю микросхему ЦАП(цифро-аналоговый преобразователь).
Тем не менее, можно сымитировать генерацию аналоговых значений на цифровых контактах с помощью широтно-импульсной модуляции (ШИМ).
Для некоторых контактов Arduino сформировать ШИМ-сигнал можно командой analogWrite().
Контакты, которые могут выдавать ШИМ-сигнал на определенные периферийные устройства, помечены символом - на плате Arduino. На Arduino Uno контакты 3, 5, 6, 9, 10, 11 поддерживают выдачу ШИМ-сигнала.
При наличии Arduino Uno проверить команду analogWrite() можно с помощью схемы, изображенной на рисунке.
Если уменьшить напряжение на контакте 9 Arduino, яркость свечения светодиода должна стать меньше, потому что снизится ток, текущий через него.
Этого эффекта можно добиться с помощью ШИМ и команды analogWrite().
Функция analogWrite() имеет два аргумента: номер контакта и 8-разрядное значение в диапазоне от 0 до 255, устанавливаемое на этом контакте.
В листинге 3.3 приведен код программы генерации ШИМ-сигнала на контакте 9 для плавного управления яркостью светодиода.</Text>
      <Pics>
        <Pic>\lessons\lesson_3\pic\pic3.1.jpg</Pic>
      </Pics>
    </Theory>
    <Theory>
      <Title>3.8.2) Листинг 3.3. Плавное изменение яркости светодиода — fade.ino</Title>
      <Text>const int LED = 9; // Константа номера контакта светодиода
void setup()
{
	pinMode (LED, OUTPUT); // Конфигурируем контакт светодиода как выход
}
void loop()
{
	for (int i = 0; i < 256; i++)
	{
		analogWrite(LED, i);
		delay (10);
	}
	for (int i = 255; i >= 0; i--)
	{
		analogWrite(LED, i);
		delay(10);
	}
}</Text>
      <Pics />
    </Theory>
    <Theory>
      <Title>3.8.3) Пояснение к листингу 3.3. Плавное изменение яркости светодиода — fade.ino</Title>
      <Text>Что будет происходить со светодиодом при выполнении листинга 2.3?
Вы будете наблюдать, как свечение светодиода изменяется от тусклого к яркому в одном цикле for, а затем от яркого к тусклому в другом цикле for.
Все это будет происходить в основном цикле loop() до бесконечности.
Обязательно обратите внимание на различие двух циклов for.
В первом цикле выражение i++ является сокращением кода i = i + 1.
Аналогично, запись i-- эквивалентна коду i = i - 1.
Первый цикл плавно зажигает светодиод до его максимальной яркости, второй - постепенно гасит его.
Во многих случаях ШИМ пригодна для эмуляции аналогового выхода, но когда требуется неискаженный аналоговый сигнал, этот вариант неприемлем.
Например, ШИМ отлично подходит для регулировки скорости двигателя постоянного тока (примеры будут приведены в следующих главах), но не годится для управления аудиоколонками (без дополнительной внешней схемы).</Text>
      <Pics />
    </Theory>
    <Theory>
      <Title>3.8.4) Тонкости работы ШИМ</Title>
      <Text>Чтобы понять все тонкости, разберемся, как на самом деле работает ШИМ.
Рассмотрим графики, представленные на рисунке.
ШИМ представляет собой изменение скважности (отношения периода к длительности импульса) прямоугольной последовательности импульсов.
Скважность можно трактовать как процент времени, когда прямоугольный импульс имеет уровень HIGH, ко всему периоду повторения.
Скважность 50% означает, что половину периода сигнал имеет высокий уровень, а половину - низкий.
Функция analogWrite() устанавливает скважность последовательности прямоугольных импульсов в зависимости от значения, передаваемого ей:
• значение аргумента analogWrite(), равное нулю, задает скважность 0% (всегда LOW);
• значение 255 -скважность 100% (всегда HIGH);
• значение 127 соответствует скважности 50% (половина времени HIGH, половина времени LOW).
На графиках видно, что для сигнала со скважностью 25% значение HIGH действует в течение четверти периода, а остальные 75% времени установлено значение LOW.
Частота прямоугольной последовательности импульсов в случае с Arduino составляет приблизительно 490 Гц.
Другими словами, уровень сигнала меняется от высокого (5 В) к низкому (0 В) приблизительно 490 раз каждую секунду.
Как видим, напряжение, подаваемое на светодиод, на самом деле не понижается, почему же при уменьшении скважности наблюдается спад яркости свечения светодиода?
Это связано с особенностью нашего зрения.
Если светодиод включается и выключается один раз за 1 мс (при скважности 50%), то вам кажется, что яркость свечения светодиода составляет приблизительно 50% от максимальной, потому что переключение происходит быстрее, чем глаза могут это зафиксировать.
Ваш мозг фактически усредняет сигнал и создается впечатление, что светодиод работает на половине яркости.</Text>
      <Pics>
        <Pic>\lessons\lesson_3\pic\pic3.4.jpg</Pic>
      </Pics>
    </Theory>
    <Theory>
      <Title>3.9) Считывание данных с цифровых контактов</Title>
      <Text>Рассмотрим еще одну функцию цифровых контактов. 
До сих пор мы использовали их в качестве выходов, генерируя цифровой сигнал и ШИМ-сигнал. 
Следующий шаг - функционирование контактов платы Arduino в качестве входов. 
Это позволит подключить, например, переключатели и кнопки для взаимодействия со своим устройством в режиме реального времени.
В этом разделе вы научитесь считывать значения на входе, узнаете о стягивающих и подтягивающих резисторах, сможете обрабатывать в программе нажатие кнопки.</Text>
      <Pics />
    </Theory>
    <Theory>
      <Title>3.9.1) Считывание цифровых входов со стягивающим резистором</Title>
      <Text>Изменим схему, изображенную на рисунке 1. 
Подключим к цифровому контакту кнопку и стягивающий резистор, в результате схема примет вид, представленный на рисунке 2.
Совет: Проверьте, что шины питания и земли обеих плат надежно соединены друг с другом.
Тогда в дальнейшем вы сможете легко менять элементы на макетной плате.
Прежде чем написать программу опроса состояния кнопки, важно понять назначение резистора в этой схеме.
Почти для всех цифровых входов необходим дополнительный стягивающий (pull-down) или подтягивающий (pull-up) резисторы для установки "значения по умолчанию" на входном контакте.
Представьте себе, что в схеме на рисунке 2 нет резистора 10 кОм.
В этом случае при нажатии на кнопку на выводе будет значение HIGH. Но что происходит, когда кнопка не нажата?
В такой ситуации входной контакт не привязан ни к чему, как говорят, "висит в воздухе".
А поскольку вывод физически не подключен ни к 0 В, ни к 5 В, чтение значения может дать неожиданный результат.
Электрические помехи на близлежащих выводах могут привести к тому, что значение напряжения будет колебаться между HIGH и LOW.
Чтобы предотвратить это, стягивающий резистор подключают так, как показано на рисунке 2.
Посмотрим, что происходит, когда кнопка не нажата, а входной контакт подключен через стягивающий резистор 10 кОм к земле. 
Через резистор протекает ток утечки и на входном контакте будет установлено значение напряжения LOW. 
10 кОм - довольно распространенный номинал для стягивающего резистора.
При нажатии на кнопку входной контакт оказывается напрямую связан с шиной 5 В.
Теперь ток может течь двумя путями:
• через практически нулевое сопротивление нажатой кнопки к шине 5 В;
• через высокое сопротивление резистора на землю.
В соответствии с законом Ома ток всегда будет идти по пути наименьшего сопротивления.
Большая часть тока будет протекать через замкнутую кнопку и на входе установится уровень HIGH.</Text>
      <Pics>
        <Pic>\lessons\lesson_3\pic\pic3.1.jpg</Pic>
        <Pic>\lessons\lesson_3\pic\pic3.5.jpg</Pic>
      </Pics>
    </Theory>
    <Theory>
      <Title>3.9.2) Примечание</Title>
      <Text>В рассмотренном примере используется стягивающий резистор, но возможна установка и подтягивающего резистора, подключенного к шине 5 В, тогда кнопка должна быть соединена с землей.
В таком случае на входном контакте будет значение HIGH при отпущенной кнопке и значение LOW, когда кнопка нажата.</Text>
      <Pics />
    </Theory>
    <Theory>
      <Title>3.9.3) Слова перед листингом</Title>
      <Text>Стягивающие и подтягивающие резисторы важны, потому что они гарантируют, что кнопка не создаст короткое замыкание между 5 В и землей при нажатии и что входной контакт не останется в "подвешенном" состоянии.
Теперь напишем программу для рассмотренной схемы. 
Светодиод должен гореть, пока кнопка нажата, и быть выключенным, когда кнопка отжата.</Text>
      <Pics />
    </Theory>
    <Theory>
      <Title>3.9.4) Листинг 3.4. Включение светодиода с помощью кнопки — led_button.ino</Title>
      <Text>const int LED = 9; // Контакт 9 для подключения светодиода
const int BUTTON = 2; // Контакт 2 для подключения кнопки
void setup()
{
	pinMode (LED, OUTPUT); // Сконфигурировать контакт светодиода как выход
	pinMode (BUTTON, INPUT); // Сконфигурировать контакт кнопки как вход
}
void loop()
{
	if (digitalRead(BUTTON) == LOW)
	{
		digitalWrite(LED, LOW);
	}
	else
	{
		digitalWrite(LED, HIGH);
	}
}</Text>
      <Pics />
    </Theory>
    <Theory>
      <Title>3.9.5) Комментарии к листингу 3.4</Title>
      <Text>В коде листинга 3.4 реализованы некоторые новые элементы: функция digitalRead() и оператор if-else.
Константа BUTTON типа int добавлена для контакта кнопки. Кроме того, в функции setup() конфигурируем контакт BUTTON как вход.
Это необязательно, т. к. выводы Arduino являются входами по умолчанию.
Функция digitalRead() считывает значение сигнала на входе.
Если кнопка нажата, digitalRead() возвращает значение HIGH (лог. 1).
Если кнопка не нажата, то получаем LOW (лог. 0).
Проверяем содержимое внутри оператора if(). Если условие внутри оператора if() истинно (кнопка не нажата, digitalRead() ==LOW), вызываем функцию digitalWrite (LED, LOW) (гасим светодиод).
В противном случае (кнопка нажата) выполняем код после оператора else (включаем светодиод функцией digitalWrite(LED, HIGH)).
Вот и все! Загружаем данный код на плату Arduino и убеждаемся, что все работает, как и ожидалось.</Text>
      <Pics />
    </Theory>
    <Theory>
      <Title>3.10) Устранение "дребезга" кнопок</Title>
      <Text>Удобно ли держать кнопку постоянно нажатой для свечения светодиода? 
Гораздо лучше иметь возможность нажать кнопку один раз, чтобы включить светодиод, и нажав ее еще раз, выключить.
При таком варианте, для горения светодиода кнопку не придется удерживать нажатой.
К сожалению, сделать это не так легко, как кажется.
Нельзя просто считывать значение сигнала на входе, необходимо учитывать явление, называемое дребезгом контактов.
Обычные кнопки представляют собой механические устройства с пружинным контактом.
При нажатии на кнопку сигнал не просто меняется от низкого до высокого, он на протяжении нескольких миллисекунд неоднократно меняет свое значение, прежде чем установится уровень LOW.</Text>
      <Pics />
    </Theory>
    <Theory>
      <Title>3.10.1) Устранение "дребезга" кнопок</Title>
      <Text>Отличие ожидаемого процесса от реального иллюстрируют осциллограммы сигнала с кнопки, приведенные на рисунке.
Кнопка была физически нажата в течение 25 мс. 
Предположение, что состояние кнопки можно определить, считав значение с входа контакта (график слева) неверно. 
Кнопка фактически возвращается вверх-вниз, пока значение не установится (график справа). 
Теперь, зная, как ведет себя кнопка, можно написать программу для кнопки с дребезгом, которая фиксирует изменение состояния кнопки, некоторое время ждет и затем снова читает состояние переключателя.</Text>
      <Pics>
        <Pic>\lessons\lesson_3\pic\pic3.6.jpg</Pic>
      </Pics>
    </Theory>
    <Theory>
      <Title>3.10.2) Устранение "дребезга" кнопок</Title>
      <Text>Алгоритм работы такой программы можно записать следующим образом:
1. Сохраняем предыдущее и текущее состояния кнопки (при инициализации LOW).
2. Считываем текущее состояние кнопки.
3. Если текущее состояние кнопки отличается от предыдущего, ждем 5 мс, потому что кнопка, возможно, изменит свое состояние.
4. Подождав 5 мс, считываем состояние кнопки и делаем его текущим состоянием кнопки.
5. Если предыдущее состояние кнопки было LOW, а текущее - HIGH, переключаем состояние светодиода.
6. Устанавливаем предыдущее состояние кнопки в качестве текущего.
7. Возвращаемся к шагу 2.</Text>
      <Pics />
    </Theory>
    <Theory>
      <Title>3.10.3) Устранение "дребезга" кнопок</Title>
      <Text>Данный алгоритм - прекрасный пример для изучения функций.
Функция - это оператор, который может принимать входные аргументы, выполнять фрагмент кода с их использованием и, возможно, возвращать результат. 
Не зная этого, вы уже встречали функции в программах. 
Например, digitalWrite() - это функция, которая принимает в качестве аргументов номер контакта и значение (HIGH или LOW), и устанавливает это значение на контакте. 
Чтобы упростить программу, можно определить свои собственные функции для инкапсуляции действий, которые придется повторять неоднократно.</Text>
      <Pics />
    </Theory>
    <Theory>
      <Title>3.10.4) Устранение "дребезга" кнопок</Title>
      <Text>Процесс выполнения программы представляет собой многократное повторение шагов.
Напишем функцию для устранения дребезга контактов, которую можно вызывать неоднократно.
Наша функция будет принимать предыдущее состояние кнопки в качестве входных данных, выполнять противодребезговую защиту и выводить установившееся состояние кнопки.
Основной цикл программы переключает состояние светодиода при каждом нажатии кнопки.
Загрузите код листинга 3.5 в плату Arduino и посмотрите, как он работает.</Text>
      <Pics />
    </Theory>
    <Theory>
      <Title>3.10.5) Листинг 3.5. Подавление дребезга кнопки — debounce.ino</Title>
      <Text>const int LED = 9; // Контакт 9 для подключения светодиода
const int BUTTON = 2; // Контакт 2 для подключения кнопки
boolean lastButton = LOW;// Переменная для сохранения предыдущего
// состояния кнопки
boolean currentButton = LOW;// Переменная для сохранения текущего
// состояния кнопки
boolean ledOn = false;// Текущее состояние светодиода
//(включен/выключен)
void setup()
{
 pinMode (LED, OUTPUT);// Сконфигурировать контакт светодиода как выход
 pinMode (BUTTON, INPUT);//Сконфигурировать контакт кнопки как вход
}
/*
* Функция сглаживания дребезга
* принимает в качестве аргумента предыдущее состояние кнопки
* и выдает фактическое.
*/
boolean debounce(boolean last)
{
	boolean current = digitalRead(BUTTON);// Считать состояние кнопки
	if (last != current)// Если изменилось...
	{
		delay(5);// Ждем 5 мс
		current = digitalRead(BUTTON);// Считываем состояние кнопки
		return current;// Возвращаем состояние кнопки
	}
}
void loop()
{
	currentButton = debounce(lastButton);
	if (lastButton == LOW && currentButton == HIGH) // Если нажатие
	{
		ledOn = !ledOn;// Инвертировать значение состояния светодиода
	}
	lastButton = currentButton;
	digitalWrite(LED, ledOn);// Изменить статус состояния светодиода
}</Text>
      <Pics />
    </Theory>
    <Theory>
      <Title>3.10.6) Устранение "дребезга" кнопок</Title>
      <Text>Теперь рассмотрим текст листинга 3.5 подробнее.
Сначала заданы номера контактов для подключения кнопки и светодиода.
Затем объявлены три глобальные логические переменные, которые будут изменяться в программе (значение глобальной переменной можно менять в любой части программы).
Каждой из трех переменных присвоены начальные значения (LOW, LOW и false).
Далее в программе значения этих переменных могут изменяться с помощью оператора присваивания =.</Text>
      <Pics />
    </Theory>
    <Theory>
      <Title>3.10.7) Устранение "дребезга" кнопок</Title>
      <Text>Рассмотрим функцию подавления дребезга кнопки boolean debounce().
Эта функция принимает логическую переменную (имеющую только два состояния: true/false, HIGH/LOW, вкл./выкл., 1/0) предыдущего состояния кнопки и возвращает текущее значение состояния кнопки. 
Внутри функции текущее состояние кнопки сравнивается с предыдущим с помощью оператора != (не равно). Если состояния отличаются, то кнопка, возможно, нажата. 
Затем ожидаем 5 мс (этого достаточно, чтобы состояние кнопки стабилизировалось после дребезга), прежде чем проверить состояние кнопки снова. 
Затем вновь проверяем состояние кнопки. Как вы помните, функции могут возвращать результат. 
Данная функция возвращает текущее значение булевой локальной переменной, которая объявлена и используется только в функции debounce().</Text>
      <Pics />
    </Theory>
    <Theory>
      <Title>3.10.8) Устранение "дребезга" кнопок</Title>
      <Text>Когда функция debounce() вызывается из основного цикла, возвращенное значение записывается в глобальную переменную currentButton, которая была определена в начале программы.
После вызова функции debounce() и установки значения переменной currentButton происходит сравнение текущего и предыдущего значений состояния кнопки с помощью оператора && (логический оператор "И", означающий, что выражение в скобках выполнится, только если истинно каждое из равенств, разделенных оператором &&).</Text>
      <Pics />
    </Theory>
    <Theory>
      <Title>3.10.9) Устранение "дребезга" кнопок</Title>
      <Text>Если ранее состояние кнопки было LOW, а теперь HIGH, значит, кнопка была нажата и нужно инвертировать значение переменной lecton.
Это действие выполняет оператор перед переменной lecton.
Цикл закончен, обновляем предыдущую перемеую состояния кнопки и изменяем состояние светодиода.
Программа изменяет состояние светодиода после каждого нажатия кнопки.
При отсутствии проверки дребезга кнопки результаты будут непредсказуемыми.</Text>
      <Pics />
    </Theory>
    <Theory>
      <Title>Итоги</Title>
      <Text>В этом уроке вы узнали о следующем:
•Как работать с макетной платой.
•Как выбрать резистор для ограничения тока светодиода.
•Как подключить внешний светодиод к плате Arduino.
•Как использовать ШИМ, как замену аналогового вывода.
•Как считывать состояние кнопки.
•Как подавить дребезг кнопки.
•Для чего нужны подтягивающий и стягивающий резисторы.</Text>
      <Pics />
    </Theory>
  </Theories>
  <Tests>
    <Test>
      <Title>test</Title>
      <Pics />
      <Text>test</Text>
      <Variants>
        <Variant>False1</Variant>
        <Variant>False2</Variant>
        <Variant>True</Variant>
        <Variant>False3</Variant>
      </Variants>
      <Answer>2</Answer>
    </Test>
  </Tests>
</Lesson>